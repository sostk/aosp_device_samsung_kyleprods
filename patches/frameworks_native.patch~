From ff85f2d4675261531c8fd9f670d106605cbd1d3d Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sun, 25 Dec 2011 17:37:53 +0700
Subject: [PATCH 1/10] installd: Delete cache properly for devices using
 datadata partition

The java side already checks /data/data for free space but installd
still checks /data causing it to never reap the cache (because it
thinks that enough free space is available.)

Change-Id: I736af6ff7ea0c8ae07900168f6b8ac2f7a4dbe0b
---
 cmds/installd/commands.c | 1 +
 cmds/installd/installd.c | 5 +++++
 cmds/installd/installd.h | 3 +++
 cmds/installd/utils.c    | 6 +++++-
 4 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/cmds/installd/commands.c b/cmds/installd/commands.c
index 84ad204..d1832a8 100644
--- a/cmds/installd/commands.c
+++ b/cmds/installd/commands.c
@@ -21,6 +21,7 @@
 
 /* Directory records that are used in execution of commands. */
 dir_rec_t android_data_dir;
+dir_rec_t android_datadata_dir;
 dir_rec_t android_asec_dir;
 dir_rec_t android_app_dir;
 dir_rec_t android_app_private_dir;
diff --git a/cmds/installd/installd.c b/cmds/installd/installd.c
index 1904408..76c3feb 100644
--- a/cmds/installd/installd.c
+++ b/cmds/installd/installd.c
@@ -268,6 +268,11 @@ int initialize_globals() {
         return -1;
     }
 
+    // Get the android datadata directory.
+    if (copy_and_append(&android_datadata_dir, &android_data_dir, DATA_SUBDIR) < 0) {
+        return -1;
+    }
+
     // Get the android app directory.
     if (copy_and_append(&android_app_dir, &android_data_dir, APP_SUBDIR) < 0) {
         return -1;
diff --git a/cmds/installd/installd.h b/cmds/installd/installd.h
index 635b07c..1671038 100644
--- a/cmds/installd/installd.h
+++ b/cmds/installd/installd.h
@@ -60,6 +60,8 @@
 
 #define CACHE_DIR_POSTFIX      "/cache"
 
+#define DATA_SUBDIR             "data/" // sub-directory under ANDROID_DATA
+
 #define APP_SUBDIR             "app/" // sub-directory under ANDROID_DATA
 
 #define APP_LIB_SUBDIR         "app-lib/" // sub-directory under ANDROID_DATA
@@ -94,6 +96,7 @@ extern dir_rec_t android_app_dir;
 extern dir_rec_t android_app_private_dir;
 extern dir_rec_t android_app_lib_dir;
 extern dir_rec_t android_data_dir;
+extern dir_rec_t android_datadata_dir;
 extern dir_rec_t android_asec_dir;
 extern dir_rec_t android_media_dir;
 extern dir_rec_array_t android_system_dirs;
diff --git a/cmds/installd/utils.c b/cmds/installd/utils.c
index ef634c6..722ed50 100644
--- a/cmds/installd/utils.c
+++ b/cmds/installd/utils.c
@@ -363,7 +363,11 @@ int lookup_media_dir(char basepath[PATH_MAX], const char *dir)
 int64_t data_disk_free()
 {
     struct statfs sfs;
-    if (statfs(android_data_dir.path, &sfs) == 0) {
+    /* Scanning /data/data because on some devices, it's on a different partition
+     * and scanning /data will yield the incorrect result. (This function is only
+     * used for freeing space on /data/data so it is okay to be more specific.)
+     */
+    if (statfs(android_datadata_dir.path, &sfs) == 0) {
         return sfs.f_bavail * sfs.f_bsize;
     } else {
         ALOGE("Couldn't statfs %s: %s\n", android_data_dir.path, strerror(errno));
-- 
2.3.7


From f1c8d195fc59ed0d97165387d2c7c05d0c913bf8 Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date: Thu, 31 Oct 2013 03:53:39 +0000
Subject: [PATCH 2/10] Revert "remove support for glReadPixels screenshot path"

This reverts commit 3ca76f416bc8665a97636ca8a2d0128b9da9d92c.
---
 include/gui/ISurfaceComposer.h                     |  3 +-
 libs/gui/ISurfaceComposer.cpp                      |  8 +++-
 libs/gui/SurfaceComposerClient.cpp                 |  5 ++-
 .../RenderEngine/GLES11RenderEngine.cpp            | 43 +++++++++++++++-------
 .../RenderEngine/GLES11RenderEngine.h              |  4 +-
 .../RenderEngine/GLES20RenderEngine.cpp            | 41 +++++++++++++++------
 .../RenderEngine/GLES20RenderEngine.h              |  5 ++-
 .../surfaceflinger/RenderEngine/RenderEngine.cpp   |  8 ++--
 .../surfaceflinger/RenderEngine/RenderEngine.h     |  7 ++--
 services/surfaceflinger/SurfaceFlinger.cpp         | 34 +++++++++++++----
 services/surfaceflinger/SurfaceFlinger.h           |  5 ++-
 11 files changed, 113 insertions(+), 50 deletions(-)

diff --git a/include/gui/ISurfaceComposer.h b/include/gui/ISurfaceComposer.h
index 5c3c99c..319aeaa 100644
--- a/include/gui/ISurfaceComposer.h
+++ b/include/gui/ISurfaceComposer.h
@@ -120,7 +120,8 @@ public:
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ) = 0;
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool isCpuConsumer) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index aab0604..6d22066 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -105,7 +105,8 @@ public:
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ)
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool isCpuConsumer)
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
@@ -115,6 +116,7 @@ public:
         data.writeInt32(reqHeight);
         data.writeInt32(minLayerZ);
         data.writeInt32(maxLayerZ);
+        data.writeInt32(isCpuConsumer);
         remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN, data, &reply);
         return reply.readInt32();
     }
@@ -285,8 +287,10 @@ status_t BnSurfaceComposer::onTransact(
             uint32_t reqHeight = data.readInt32();
             uint32_t minLayerZ = data.readInt32();
             uint32_t maxLayerZ = data.readInt32();
+            bool isCpuConsumer = data.readInt32();
             status_t res = captureScreen(display, producer,
-                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    isCpuConsumer);
             reply->writeInt32(res);
             return NO_ERROR;
         }
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index aafc4d2..7962715 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -627,7 +627,8 @@ status_t ScreenshotClient::capture(
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
     return s->captureScreen(display, producer,
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            false);
 }
 
 ScreenshotClient::ScreenshotClient()
@@ -662,7 +663,7 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
     }
 
     status_t err = s->captureScreen(display, mBufferQueue,
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ, true);
 
     if (err == NO_ERROR) {
         err = mCpuConsumer->lockNextBuffer(&mBuffer);
diff --git a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
index 521a5d2..da69965 100644
--- a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
+++ b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
@@ -185,28 +185,45 @@ void GLES11RenderEngine::disableBlending() {
 }
 
 void GLES11RenderEngine::bindImageAsFramebuffer(EGLImageKHR image,
-        uint32_t* texName, uint32_t* fbName, uint32_t* status) {
+        uint32_t* texName, uint32_t* fbName, uint32_t* status,
+        bool useReadPixels, int reqWidth, int reqHeight) {
     GLuint tname, name;
-    // turn our EGLImage into a texture
-    glGenTextures(1, &tname);
-    glBindTexture(GL_TEXTURE_2D, tname);
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
-
-    // create a Framebuffer Object to render into
-    glGenFramebuffersOES(1, &name);
-    glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
-    glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES,
-            GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, tname, 0);
+    if (!useReadPixels) {
+        // turn our EGLImage into a texture
+        glGenTextures(1, &tname);
+        glBindTexture(GL_TEXTURE_2D, tname);
+        glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
+
+        // create a Framebuffer Object to render into
+        glGenFramebuffersOES(1, &name);
+        glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
+        glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES,
+                GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, tname, 0);
+    } else {
+        // since we're going to use glReadPixels() anyways,
+        // use an intermediate renderbuffer instead
+        glGenRenderbuffersOES(1, &tname);
+        glBindRenderbufferOES(GL_RENDERBUFFER_OES, tname);
+        glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_RGBA8_OES, reqWidth, reqHeight);
+        // create a FBO to render into
+        glGenFramebuffersOES(1, &name);
+        glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
+        glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, tname);
+    }
 
     *status = glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES);
     *texName = tname;
     *fbName = name;
 }
 
-void GLES11RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName) {
+void GLES11RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName,
+        bool useReadPixels) {
     glBindFramebufferOES(GL_FRAMEBUFFER_OES, 0);
     glDeleteFramebuffersOES(1, &fbName);
-    glDeleteTextures(1, &texName);
+    if (!useReadPixels)
+        glDeleteTextures(1, &texName);
+    else
+        glDeleteRenderbuffersOES(1, &texName);
 }
 
 void GLES11RenderEngine::setupFillWithColor(float r, float g, float b, float a) {
diff --git a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
index cd53aab..6e4c46e 100644
--- a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
+++ b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
@@ -39,8 +39,8 @@ class GLES11RenderEngine : public RenderEngine {
     GLint mMaxTextureSize;
 
     virtual void bindImageAsFramebuffer(EGLImageKHR image,
-            uint32_t* texName, uint32_t* fbName, uint32_t* status);
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName);
+            uint32_t* texName, uint32_t* fbName, uint32_t* status, bool useReadPixels, int reqWidth, int reqHeight);
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels);
 
 public:
     GLES11RenderEngine();
diff --git a/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp b/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
index a2a6270..ada3ab0 100644
--- a/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
+++ b/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
@@ -151,27 +151,44 @@ void GLES20RenderEngine::disableBlending() {
 
 
 void GLES20RenderEngine::bindImageAsFramebuffer(EGLImageKHR image,
-        uint32_t* texName, uint32_t* fbName, uint32_t* status) {
+        uint32_t* texName, uint32_t* fbName, uint32_t* status,
+        bool useReadPixels, int reqWidth, int reqHeight) {
     GLuint tname, name;
-    // turn our EGLImage into a texture
-    glGenTextures(1, &tname);
-    glBindTexture(GL_TEXTURE_2D, tname);
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
-
-    // create a Framebuffer Object to render into
-    glGenFramebuffers(1, &name);
-    glBindFramebuffer(GL_FRAMEBUFFER, name);
-    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tname, 0);
+    if (!useReadPixels) {
+        // turn our EGLImage into a texture
+        glGenTextures(1, &tname);
+        glBindTexture(GL_TEXTURE_2D, tname);
+        glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
+
+        // create a Framebuffer Object to render into
+        glGenFramebuffers(1, &name);
+        glBindFramebuffer(GL_FRAMEBUFFER, name);
+        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tname, 0);
+    } else {
+        // since we're going to use glReadPixels() anyways,
+        // use an intermediate renderbuffer instead
+        glGenRenderbuffers(1, &tname);
+        glBindRenderbuffer(GL_RENDERBUFFER, tname);
+        glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8_OES, reqWidth, reqHeight);
+        // create a FBO to render into
+        glGenFramebuffers(1, &name);
+        glBindFramebuffer(GL_FRAMEBUFFER, name);
+        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, tname);
+    }
 
     *status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
     *texName = tname;
     *fbName = name;
 }
 
-void GLES20RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName) {
+void GLES20RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName,
+        bool useReadPixels) {
     glBindFramebuffer(GL_FRAMEBUFFER, 0);
     glDeleteFramebuffers(1, &fbName);
-    glDeleteTextures(1, &texName);
+    if (!useReadPixels)
+        glDeleteTextures(1, &texName);
+    else
+        glDeleteRenderbuffers(1, &texName);
 }
 
 void GLES20RenderEngine::setupFillWithColor(float r, float g, float b, float a) {
diff --git a/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h b/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
index 8b67fcc..d5c5b5d 100644
--- a/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
+++ b/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
@@ -54,8 +54,9 @@ class GLES20RenderEngine : public RenderEngine {
     Vector<Group> mGroupStack;
 
     virtual void bindImageAsFramebuffer(EGLImageKHR image,
-            uint32_t* texName, uint32_t* fbName, uint32_t* status);
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName);
+            uint32_t* texName, uint32_t* fbName, uint32_t* status,
+            bool useReadPixels, int reqWidth, int reqHeight);
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels);
 
 public:
     GLES20RenderEngine();
diff --git a/services/surfaceflinger/RenderEngine/RenderEngine.cpp b/services/surfaceflinger/RenderEngine/RenderEngine.cpp
index ba82cad..8a8ee56 100644
--- a/services/surfaceflinger/RenderEngine/RenderEngine.cpp
+++ b/services/surfaceflinger/RenderEngine/RenderEngine.cpp
@@ -217,9 +217,11 @@ void RenderEngine::dump(String8& result) {
 // ---------------------------------------------------------------------------
 
 RenderEngine::BindImageAsFramebuffer::BindImageAsFramebuffer(
-        RenderEngine& engine, EGLImageKHR image) : mEngine(engine)
+        RenderEngine& engine, EGLImageKHR image, bool useReadPixels,
+        int reqWidth, int reqHeight) : mEngine(engine), mUseReadPixels(useReadPixels)
 {
-    mEngine.bindImageAsFramebuffer(image, &mTexName, &mFbName, &mStatus);
+    mEngine.bindImageAsFramebuffer(image, &mTexName, &mFbName, &mStatus,
+            useReadPixels, reqWidth, reqHeight);
 
     ALOGE_IF(mStatus != GL_FRAMEBUFFER_COMPLETE_OES,
             "glCheckFramebufferStatusOES error %d", mStatus);
@@ -227,7 +229,7 @@ RenderEngine::BindImageAsFramebuffer::BindImageAsFramebuffer(
 
 RenderEngine::BindImageAsFramebuffer::~BindImageAsFramebuffer() {
     // back to main framebuffer
-    mEngine.unbindFramebuffer(mTexName, mFbName);
+    mEngine.unbindFramebuffer(mTexName, mFbName, mUseReadPixels);
 }
 
 status_t RenderEngine::BindImageAsFramebuffer::getStatus() const {
diff --git a/services/surfaceflinger/RenderEngine/RenderEngine.h b/services/surfaceflinger/RenderEngine/RenderEngine.h
index 3c7f9ab..e69b914 100644
--- a/services/surfaceflinger/RenderEngine/RenderEngine.h
+++ b/services/surfaceflinger/RenderEngine/RenderEngine.h
@@ -47,8 +47,8 @@ class RenderEngine {
     EGLContext mEGLContext;
     void setEGLContext(EGLContext ctxt);
 
-    virtual void bindImageAsFramebuffer(EGLImageKHR image, uint32_t* texName, uint32_t* fbName, uint32_t* status) = 0;
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName) = 0;
+    virtual void bindImageAsFramebuffer(EGLImageKHR image, uint32_t* texName, uint32_t* fbName, uint32_t* status, bool useReadPixels, int reqWidth, int reqHeight) = 0;
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels) = 0;
 
 protected:
     RenderEngine();
@@ -76,8 +76,9 @@ public:
         RenderEngine& mEngine;
         uint32_t mTexName, mFbName;
         uint32_t mStatus;
+        bool mUseReadPixels;
     public:
-        BindImageAsFramebuffer(RenderEngine& engine, EGLImageKHR image);
+        BindImageAsFramebuffer(RenderEngine& engine, EGLImageKHR image, bool useReadPixels, int reqWidth, int reqHeight);
         ~BindImageAsFramebuffer();
         int getStatus() const;
     };
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 9d94c87..3c5968e 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2839,7 +2839,8 @@ public:
 status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ) {
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels) {
 
     if (CC_UNLIKELY(display == 0))
         return BAD_VALUE;
@@ -2865,16 +2866,18 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         sp<IGraphicBufferProducer> producer;
         uint32_t reqWidth, reqHeight;
         uint32_t minLayerZ,maxLayerZ;
+        bool useReadPixels;
         status_t result;
     public:
         MessageCaptureScreen(SurfaceFlinger* flinger,
                 const sp<IBinder>& display,
                 const sp<IGraphicBufferProducer>& producer,
                 uint32_t reqWidth, uint32_t reqHeight,
-                uint32_t minLayerZ, uint32_t maxLayerZ)
+                uint32_t minLayerZ, uint32_t maxLayerZ, bool useReadPixels)
             : flinger(flinger), display(display), producer(producer),
               reqWidth(reqWidth), reqHeight(reqHeight),
               minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              useReadPixels(useReadPixels),
               result(PERMISSION_DENIED)
         {
         }
@@ -2884,8 +2887,10 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         virtual bool handler() {
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
             result = flinger->captureScreenImplLocked(hw,
-                    producer, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+                    producer, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    useReadPixels);
             static_cast<GraphicProducerWrapper*>(producer->asBinder().get())->exit(result);
             return true;
         }
@@ -2907,7 +2912,8 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
     // which does the marshaling work forwards to our "fake remote" above.
     sp<MessageBase> msg = new MessageCaptureScreen(this,
             display, IGraphicBufferProducer::asInterface( wrapper ),
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            useReadPixels);
 
     status_t res = postMessageAsync(msg);
     if (res == NO_ERROR) {
@@ -2967,7 +2973,8 @@ status_t SurfaceFlinger::captureScreenImplLocked(
         const sp<const DisplayDevice>& hw,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ)
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels)
 {
     ATRACE_CALL();
 
@@ -2991,8 +2998,10 @@ status_t SurfaceFlinger::captureScreenImplLocked(
 
     status_t result = NO_ERROR;
     if (native_window_api_connect(window, NATIVE_WINDOW_API_EGL) == NO_ERROR) {
-        uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN |
-                        GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
+        uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN;
+        if (!useReadPixels) {
+            usage |= GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
+        }
 
         int err = 0;
         err = native_window_set_buffers_dimensions(window, reqWidth, reqHeight);
@@ -3014,7 +3023,7 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                 if (image != EGL_NO_IMAGE_KHR) {
                     // this binds the given EGLImage as a framebuffer for the
                     // duration of this scope.
-                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image);
+                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image, useReadPixels, reqWidth, reqHeight);
                     if (imageBond.getStatus() == NO_ERROR) {
                         // this will in fact render into our dequeued buffer
                         // via an FBO, which means we didn't have to create
@@ -3044,6 +3053,15 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                             // not fatal
                         }
 
+                        if (useReadPixels) {
+                            sp<GraphicBuffer> buf = static_cast<GraphicBuffer*>(buffer);
+                            void* vaddr;
+                            if (buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, &vaddr) == NO_ERROR) {
+                                getRenderEngine().readPixels(0, 0, buffer->stride, reqHeight, (uint32_t *)vaddr);
+                                buf->unlock();
+                            }
+                        }
+
                         if (DEBUG_SCREENSHOTS) {
                             uint32_t* pixels = new uint32_t[reqWidth*reqHeight];
                             getRenderEngine().readPixels(0, 0, reqWidth, reqHeight, pixels);
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index f08e66a..5b98685 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -202,7 +202,7 @@ private:
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ);
+            uint32_t minLayerZ, uint32_t maxLayerZ, bool isCpuConsumer);
     // called when screen needs to turn off
     virtual void blank(const sp<IBinder>& display);
     // called when screen is turning back on
@@ -312,7 +312,8 @@ private:
             const sp<const DisplayDevice>& hw,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ);
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useReadPixels);
 
     /* ------------------------------------------------------------------------
      * EGL
-- 
2.3.7


From dd53258f4964e462d3767b34988ece8b732536fb Mon Sep 17 00:00:00 2001
From: Hashcode <hashcode0f@gmail.com>
Date: Sun, 8 Dec 2013 19:36:50 +0000
Subject: [PATCH 3/10] sf: Always use opengles for screen capture

Go back to the usage of GRALLOC_USAGE_HW_TEXTURE and GRALLOC_USAGE_HW_RENDERER
in captureScreenImplLocked regardless of useReadPixels value

This fixes the EGL_NO_IMAGE_KHR error returned from
eglCreateImageKHR (blank images returned from screenshot path)

Change-Id: I62fe90a081607b9e89c67f3dcfd34c84efc89d35
---
 services/surfaceflinger/SurfaceFlinger.cpp | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 3c5968e..3293f1b 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2998,10 +2998,8 @@ status_t SurfaceFlinger::captureScreenImplLocked(
 
     status_t result = NO_ERROR;
     if (native_window_api_connect(window, NATIVE_WINDOW_API_EGL) == NO_ERROR) {
-        uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN;
-        if (!useReadPixels) {
-            usage |= GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
-        }
+        uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN |
+                        GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
 
         int err = 0;
         err = native_window_set_buffers_dimensions(window, reqWidth, reqHeight);
-- 
2.3.7


From 04fc9261e44945f7eba20053835bec3428b5131b Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date: Tue, 6 Aug 2013 16:11:06 +0100
Subject: [PATCH 4/10] libgui: Bring back support for mHeap-based screenshots

Older graphics libraries throw a hissy fit when trying to lock
buffers for Surface-based screenshots, on at least Tegra2/3 and
Exynos4 hardware.

This patch depends on the BOARD_USE_MHEAP_SCREENSHOT board flag
and requires the ro.bq.gpu_to_cpu_unsupported property set to 1
in order to work.

Change-Id: I7db955e2cdd120018e349c14290e975788e70ed3
---
 include/gui/ISurfaceComposer.h             |  13 +++
 include/gui/SurfaceComposerClient.h        |   6 ++
 libs/gui/Android.mk                        |   3 +
 libs/gui/ISurfaceComposer.cpp              |  41 +++++++++
 libs/gui/SurfaceComposerClient.cpp         |  26 ++++++
 services/surfaceflinger/Android.mk         |   4 +
 services/surfaceflinger/SurfaceFlinger.cpp | 128 ++++++++++++++++++++++++++++-
 services/surfaceflinger/SurfaceFlinger.h   |  13 +++
 8 files changed, 231 insertions(+), 3 deletions(-)

diff --git a/include/gui/ISurfaceComposer.h b/include/gui/ISurfaceComposer.h
index 319aeaa..4264248 100644
--- a/include/gui/ISurfaceComposer.h
+++ b/include/gui/ISurfaceComposer.h
@@ -122,6 +122,16 @@ public:
             uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool isCpuConsumer) = 0;
+
+#ifdef USE_MHEAP_SCREENSHOT
+    /* Capture the specified screen. requires READ_FRAME_BUFFER permission
+     * This function will fail if there is a secure window on screen.
+     */
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ) = 0;
+#endif
 };
 
 // ----------------------------------------------------------------------------
@@ -140,6 +150,9 @@ public:
         GET_BUILT_IN_DISPLAY,
         SET_TRANSACTION_STATE,
         AUTHENTICATE_SURFACE,
+#ifdef USE_MHEAP_SCREENSHOT
+        CAPTURE_SCREEN_DEPRECATED,
+#endif
         BLANK,
         UNBLANK,
         GET_DISPLAY_INFO,
diff --git a/include/gui/SurfaceComposerClient.h b/include/gui/SurfaceComposerClient.h
index e982bcd..c630a94 100644
--- a/include/gui/SurfaceComposerClient.h
+++ b/include/gui/SurfaceComposerClient.h
@@ -39,6 +39,9 @@ namespace android {
 
 class DisplayInfo;
 class Composer;
+#ifdef USE_MHEAP_SCREENSHOT
+class IMemoryHeap;
+#endif
 class ISurfaceComposerClient;
 class IGraphicBufferProducer;
 class Region;
@@ -167,6 +170,9 @@ public:
             uint32_t minLayerZ, uint32_t maxLayerZ);
 
 private:
+#ifdef USE_MHEAP_SCREENSHOT
+    sp<IMemoryHeap> mHeap;
+#endif
     mutable sp<CpuConsumer> mCpuConsumer;
     mutable sp<BufferQueue> mBufferQueue;
     CpuConsumer::LockedBuffer mBuffer;
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index c14c950..a07fdc3 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -39,6 +39,9 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	liblog
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
 
 LOCAL_MODULE:= libgui
 
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index 6d22066..ccde018 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -102,6 +102,28 @@ public:
         remote()->transact(BnSurfaceComposer::BOOT_FINISHED, data, &reply);
     }
 
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(
+            const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeStrongBinder(display);
+        data.writeInt32(reqWidth);
+        data.writeInt32(reqHeight);
+        data.writeInt32(minLayerZ);
+        data.writeInt32(maxLayerZ);
+        remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN_DEPRECATED, data, &reply);
+        *heap = interface_cast<IMemoryHeap>(reply.readStrongBinder());
+        *width = reply.readInt32();
+        *height = reply.readInt32();
+        return reply.readInt32();
+    }
+#endif
+
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
@@ -278,6 +300,25 @@ status_t BnSurfaceComposer::onTransact(
             bootFinished();
             return NO_ERROR;
         }
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            sp<IBinder> display = data.readStrongBinder();
+            uint32_t reqWidth = data.readInt32();
+            uint32_t reqHeight = data.readInt32();
+            uint32_t minLayerZ = data.readInt32();
+            uint32_t maxLayerZ = data.readInt32();
+            sp<IMemoryHeap> heap;
+            uint32_t w, h;
+            status_t res = captureScreen(display, &heap, &w, &h,
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reply->writeStrongBinder(heap->asBinder());
+            reply->writeInt32(w);
+            reply->writeInt32(h);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }
+#endif
         case CAPTURE_SCREEN: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index 7962715..a521456 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -626,6 +626,14 @@ status_t ScreenshotClient::capture(
         uint32_t minLayerZ, uint32_t maxLayerZ) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int format = 0;
+    producer->query(NATIVE_WINDOW_FORMAT,&format);
+    if (format == PIXEL_FORMAT_RGBA_8888) {
+        /* For some reason, this format fails badly */
+        return BAD_VALUE;
+    }
+#endif
     return s->captureScreen(display, producer,
             reqWidth, reqHeight, minLayerZ, maxLayerZ,
             false);
@@ -654,6 +662,19 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         uint32_t minLayerZ, uint32_t maxLayerZ) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int ret = -1;
+    mHeap = 0;
+    ret = s->captureScreen(display, &mHeap,
+            &mBuffer.width, &mBuffer.height, reqWidth, reqHeight,
+            minLayerZ, maxLayerZ);
+    if (ret == NO_ERROR) {
+        mBuffer.format = PIXEL_FORMAT_RGBA_8888;
+        mBuffer.stride = mBuffer.width;
+        mBuffer.data = (uint8_t *)mHeap->getBase();
+    }
+    return ret;
+#else
     sp<CpuConsumer> cpuConsumer = getCpuConsumer();
 
     if (mHaveBuffer) {
@@ -672,6 +693,7 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         }
     }
     return err;
+#endif
 }
 
 status_t ScreenshotClient::update(const sp<IBinder>& display) {
@@ -684,12 +706,16 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
 }
 
 void ScreenshotClient::release() {
+#ifdef USE_MHEAP_SCREENSHOT
+    mHeap = 0;
+#else
     if (mHaveBuffer) {
         mCpuConsumer->unlockBuffer(mBuffer);
         memset(&mBuffer, 0, sizeof(mBuffer));
         mHaveBuffer = false;
     }
     mCpuConsumer.clear();
+#endif
 }
 
 void const* ScreenshotClient::getPixels() const {
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index b2bc550..20b8627 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -63,6 +63,10 @@ ifeq ($(TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK),true)
     LOCAL_CFLAGS += -DRUNNING_WITHOUT_SYNC_FRAMEWORK
 endif
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 # See build/target/board/generic/BoardConfig.mk for a description of this setting.
 ifneq ($(VSYNC_EVENT_PHASE_OFFSET_NS),)
     LOCAL_CFLAGS += -DVSYNC_EVENT_PHASE_OFFSET_NS=$(VSYNC_EVENT_PHASE_OFFSET_NS)
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 3293f1b..f6fbf7c 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -23,6 +23,9 @@
 #include <dlfcn.h>
 
 #include <EGL/egl.h>
+#ifdef USE_MHEAP_SCREENSHOT
+#include <GLES/gl.h>
+#endif
 
 #include <cutils/log.h>
 #include <cutils/properties.h>
@@ -2637,6 +2640,9 @@ status_t SurfaceFlinger::onTransact(
             const int pid = ipc->getCallingPid();
             const int uid = ipc->getCallingUid();
             if ((uid != AID_GRAPHICS) &&
+#ifdef USE_MHEAP_SCREENSHOT
+                 (uid != AID_SYSTEM) &&
+#endif
                     !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)) {
                 ALOGE("Permission Denial: "
                         "can't access SurfaceFlinger pid=%d, uid=%d", pid, uid);
@@ -2645,6 +2651,9 @@ status_t SurfaceFlinger::onTransact(
             break;
         }
         case CAPTURE_SCREEN:
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED:
+#endif
         {
             // codes that require permission check
             IPCThreadState* ipc = IPCThreadState::self();
@@ -2888,9 +2897,18 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
             bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
-            result = flinger->captureScreenImplLocked(hw,
-                    producer, reqWidth, reqHeight, minLayerZ, maxLayerZ,
-                    useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            if (!useReadPixels) {
+#endif
+                result = flinger->captureScreenImplLocked(hw,
+                        producer, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                        useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            } else {
+                // Should never get here
+                return BAD_VALUE;
+            }
+#endif
             static_cast<GraphicProducerWrapper*>(producer->asBinder().get())->exit(result);
             return true;
         }
@@ -3116,6 +3134,108 @@ void SurfaceFlinger::checkScreenshot(size_t w, size_t s, size_t h, void const* v
     }
 }
 
+#ifdef USE_MHEAP_SCREENSHOT
+status_t SurfaceFlinger::captureScreenImplCpuConsumerLocked(
+        const sp<const DisplayDevice>& hw,
+        sp<IMemoryHeap>* heap, uint32_t* w, uint32_t* h,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    ATRACE_CALL();
+
+    // get screen geometry
+    const uint32_t hw_w = hw->getWidth();
+    const uint32_t hw_h = hw->getHeight();
+
+    if ((reqWidth > hw_w) || (reqHeight > hw_h)) {
+        ALOGE("size mismatch (%d, %d) > (%d, %d)",
+                reqWidth, reqHeight, hw_w, hw_h);
+        return BAD_VALUE;
+    }
+
+    reqWidth  = (!reqWidth)  ? hw_w : reqWidth;
+    reqHeight = (!reqHeight) ? hw_h : reqHeight;
+
+    status_t result = NO_ERROR;
+
+    renderScreenImplLocked(hw, reqWidth, reqHeight, minLayerZ, maxLayerZ, true);
+
+    size_t size = reqWidth * reqHeight * 4;
+    // allocate shared memory large enough to hold the
+    // screen capture
+    sp<MemoryHeapBase> base(
+            new MemoryHeapBase(size, 0, "screen-capture") );
+    void *vaddr = base->getBase();
+    glReadPixels(0, 0, reqWidth, reqHeight,
+            GL_RGBA, GL_UNSIGNED_BYTE, vaddr);
+    if (glGetError() == GL_NO_ERROR) {
+        *heap = base;
+        *w = reqWidth;
+        *h = reqHeight;
+        result = NO_ERROR;
+    } else {
+        result = INVALID_OPERATION;
+    }
+
+    return result;
+}
+
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
+        sp<IMemoryHeap>* heap,
+        uint32_t* outWidth, uint32_t* outHeight,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    if (CC_UNLIKELY(display == 0))
+        return BAD_VALUE;
+
+    class MessageCaptureScreen : public MessageBase {
+        SurfaceFlinger* flinger;
+        sp<IBinder> display;
+        sp<IMemoryHeap>* heap;
+        uint32_t* outWidth;
+        uint32_t* outHeight;
+        uint32_t reqWidth;
+        uint32_t reqHeight;
+        uint32_t minLayerZ;
+        uint32_t maxLayerZ;
+        status_t result;
+    public:
+        MessageCaptureScreen(SurfaceFlinger* flinger,
+                const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+                uint32_t* outWidth, uint32_t* outHeight,
+                uint32_t reqWidth, uint32_t reqHeight,
+                uint32_t minLayerZ, uint32_t maxLayerZ)
+            : flinger(flinger), display(display), heap(heap),
+              outWidth(outWidth), outHeight(outHeight),
+              reqWidth(reqWidth), reqHeight(reqHeight),
+              minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              result(PERMISSION_DENIED)
+        {
+        }
+        status_t getResult() const {
+            return result;
+        }
+        virtual bool handler() {
+            Mutex::Autolock _l(flinger->mStateLock);
+            sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            result = flinger->captureScreenImplCpuConsumerLocked(hw, heap,
+                    outWidth, outHeight,
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            return true;
+        }
+    };
+
+    sp<MessageBase> msg = new MessageCaptureScreen(this, display, heap,
+            outWidth, outHeight, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+    status_t res = postMessageSync(msg);
+    if (res == NO_ERROR) {
+        res = static_cast<MessageCaptureScreen*>( msg.get() )->getResult();
+    }
+    return res;
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 SurfaceFlinger::LayerVector::LayerVector() {
@@ -3162,6 +3282,7 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 }; // namespace android
 
 
+#ifndef USE_MHEAP_SCREENSHOT
 #if defined(__gl_h_)
 #error "don't include gl/gl.h in this file"
 #endif
@@ -3169,3 +3290,4 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 #if defined(__gl2_h_)
 #error "don't include gl2/gl2.h in this file"
 #endif
+#endif
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 5b98685..696585e 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -203,6 +203,11 @@ private:
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ, bool isCpuConsumer);
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+        uint32_t* width, uint32_t* height, uint32_t reqWidth,
+        uint32_t reqHeight, uint32_t minLayerZ, uint32_t maxLayerZ);
+#endif
     // called when screen needs to turn off
     virtual void blank(const sp<IBinder>& display);
     // called when screen is turning back on
@@ -315,6 +320,14 @@ private:
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useReadPixels);
 
+#ifdef USE_MHEAP_SCREENSHOT
+    status_t captureScreenImplCpuConsumerLocked(
+            const sp<const DisplayDevice>& hw,
+            sp<IMemoryHeap>* heap, uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ);
+#endif
+
     /* ------------------------------------------------------------------------
      * EGL
      */
-- 
2.3.7


From f9b09c65b146dbf1a20bb818ed4a8738ad111873 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 2 Nov 2013 23:02:15 -0700
Subject: [PATCH 5/10] libEGL: allow devices to workaround Google bug 10194508

Most older blobs don't have the EGL_KHR_gl_colorspace
extension and need this workaround.

Change-Id: Ifc5d097c1a0b68275d23c2d191976ac96631b695
---
 opengl/libs/Android.mk | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/opengl/libs/Android.mk b/opengl/libs/Android.mk
index 528b983..016a9ae 100644
--- a/opengl/libs/Android.mk
+++ b/opengl/libs/Android.mk
@@ -51,6 +51,9 @@ endif
 ifeq ($(TARGET_BOARD_PLATFORM), omap4)
   LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
 endif
+ifeq ($(BOARD_EGL_WORKAROUND_BUG_10194508),true)
+  LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
+endif
 ifneq ($(MAX_EGL_CACHE_ENTRY_SIZE),)
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_ENTRY_SIZE=$(MAX_EGL_CACHE_ENTRY_SIZE)
 endif
-- 
2.3.7


From 24174196b6f3b2f5f8528b2d6c7f5a6e1e12869a Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Thu, 14 Nov 2013 15:19:46 +0700
Subject: [PATCH 6/10] binder: add compat symbol

Required for older Samsung libtvout

Change-Id: Ib18d2513570382432d49f302ab041230650372f2
---
 libs/binder/IPCThreadState.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index 5951a3f..8960ff9 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -362,6 +362,10 @@ status_t IPCThreadState::clearLastError()
     return err;
 }
 
+extern "C" int _ZN7android14IPCThreadState13getCallingPidEv(IPCThreadState *state) {
+    return state->getCallingPid();
+}
+
 int IPCThreadState::getCallingPid() const
 {
     return mCallingPid;
-- 
2.3.7


From 1470a1a04dc1ecdc9f5eaa12e62940bb993cc4fb Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Tue, 10 Dec 2013 19:38:17 +0700
Subject: [PATCH 7/10] binder: add compat symbols

Required for libtvservice_binder.so on I9082

Change-Id: I059e92f19e4c5a911d38faa9c4df549c75c90761
---
 libs/binder/Parcel.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index db9e0a1..bb6856c 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -819,6 +819,12 @@ status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)
     return status;
 }
 
+extern "C" status_t _ZN7android6Parcel5writeERKNS0_26FlattenableHelperInterfaceE(void *parcel, void *val);
+
+extern "C" status_t _ZN7android6Parcel5writeERKNS_11FlattenableE(void *parcel, void *val) {
+    return _ZN7android6Parcel5writeERKNS0_26FlattenableHelperInterfaceE(parcel, val);
+}
+
 status_t Parcel::write(const FlattenableHelperInterface& val)
 {
     status_t err;
@@ -1197,6 +1203,12 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     return NO_ERROR;
 }
 
+extern "C" status_t _ZNK7android6Parcel4readERNS0_26FlattenableHelperInterfaceE(void *parcel, void *val);
+
+extern "C" status_t _ZNK7android6Parcel4readERNS_11FlattenableE(void *parcel, void *val) {
+    return _ZNK7android6Parcel4readERNS0_26FlattenableHelperInterfaceE(parcel, val);
+}
+
 status_t Parcel::read(FlattenableHelperInterface& val) const
 {
     // size
-- 
2.3.7


From 06a4b78ffb9353c9186a7f2f4aff78046f74255e Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Tue, 10 Dec 2013 19:38:42 +0700
Subject: [PATCH 8/10] sf: add CAPRI_HWC compatibility

Change-Id: Iaaba61dc661fcb801ea11db58d129a01105648a3
---
 services/surfaceflinger/DisplayHardware/HWComposer.cpp | 5 +++++
 services/surfaceflinger/Layer.cpp                      | 3 +++
 2 files changed, 8 insertions(+)

diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index c7d1a90..eb4c353 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -875,13 +875,18 @@ public:
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+// CAPRI_HWC does not respect planeAlpha despite being v1.2
+#ifndef CAPRI_HWC
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+#endif
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+#ifndef CAPRI_HWC
         }
+#endif
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 61af51f..df32e68 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -1149,6 +1149,8 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
 
 void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) const {
     uint32_t orientation = 0;
+// CAPRI_HWC has display problem in landscape mode when transform is used
+#ifndef CAPRI_HWC
     if (!mFlinger->mDebugDisableTransformHint) {
         // The transform hint is used to improve performance, but we can
         // only have a single transform hint, it cannot
@@ -1159,6 +1161,7 @@ void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) const {
             orientation = 0;
         }
     }
+#endif
     mSurfaceFlingerConsumer->setTransformHint(orientation);
 }
 
-- 
2.3.7


From 0274519ec1f6155c6f50e77c9b9af0b0dce2b30a Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Mon, 16 Dec 2013 15:45:42 +0700
Subject: [PATCH 9/10] sf: CAPRI_HWC: fix rotation artifact

Change-Id: I1d9cd2a57ece5a55af318f00c7902994a77776fc
---
 services/surfaceflinger/SurfaceFlinger.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index f6fbf7c..f53c5b6 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2996,6 +2996,11 @@ status_t SurfaceFlinger::captureScreenImplLocked(
 {
     ATRACE_CALL();
 
+// Rotation artifact problems when useReadPixels is false
+#ifdef CAPRI_HWC
+    useReadPixels = true;
+#endif
+
     // get screen geometry
     const uint32_t hw_w = hw->getWidth();
     const uint32_t hw_h = hw->getHeight();
-- 
2.3.7


From 3449ad28396e48572bb120eb413a4c08f87c5b22 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 20 Dec 2014 19:09:27 +0700
Subject: [PATCH 10/10] sf: CAPRI_HWC: fix for screen recording

Change-Id: I6c7e59400eab86bc5ec0ffebbcc475fa0fa404d2
---
 libs/gui/BufferQueue.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index 146f534..5b1d642 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -353,7 +353,12 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async
                 // make sure the client is not trying to dequeue more buffers
                 // than allowed.
                 const int newUndequeuedCount = maxBufferCount - (dequeuedCount+1);
+#ifdef CAPRI_HWC
+                // HACK: for some reason, we need to reduce min undequeue for screen recording
+                const int minUndequeuedCount = getMinUndequeuedBufferCount(false);
+#else
                 const int minUndequeuedCount = getMinUndequeuedBufferCount(async);
+#endif
                 if (newUndequeuedCount < minUndequeuedCount) {
                     ST_LOGE("dequeueBuffer: min undequeued buffer count (%d) "
                             "exceeded (dequeued=%d undequeudCount=%d)",
-- 
2.3.7

